name: Release

on:
  push:
    branches: [latest-release]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  preflight:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      release_notes: ${{ steps.get-notes.outputs.release_notes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get version from package.json
        id: get-version
        run: echo "version=$(jq -r .version package.json)" >> $GITHUB_OUTPUT

      - name: Get release notes from merged PR
        id: get-notes
        uses: actions/github-script@v7
        with:
          script: |
            // Find the most recent merged PR to latest-release
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              base: 'latest-release',
              sort: 'updated',
              direction: 'desc',
              per_page: 1,
            });

            let notes = '';
            if (prs.length > 0 && prs[0].merged_at) {
              notes = prs[0].body || '';
            }

            if (!notes) {
              notes = `## Maestro v${process.env.VERSION}\n\nRelease from latest-release branch.`;
            }

            // Escape for GitHub Actions output
            const escaped = notes.replace(/%/g, '%25').replace(/\n/g, '%0A').replace(/\r/g, '%0D');
            core.setOutput('release_notes', escaped);
        env:
          VERSION: ${{ steps.get-version.outputs.version }}

  test:
    needs: preflight
    runs-on: ubuntu-22.04
    name: Test

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install frontend dependencies
        run: |
          rm -f package-lock.json
          npm install

      - name: Run frontend tests
        run: npm run test

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Build MCP server (needed by Tauri build script)
        run: cargo build --release -p maestro-mcp-server

      - name: Run Rust tests
        run: cargo test --workspace
        working-directory: src-tauri

  create-release:
    needs: [preflight, test]
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.result }}
    steps:
      - name: Create draft release
        id: create-release
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.preflight.outputs.version }}';
            const tag = `v${version}`;

            // Check if tag already exists
            try {
              await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tag}`,
              });
              core.setFailed(`Tag ${tag} already exists. Bump the version in package.json before releasing.`);
              return;
            } catch (e) {
              if (e.status !== 404) throw e;
              // Tag doesn't exist, good to proceed
            }

            const notes = decodeURIComponent(
              '${{ needs.preflight.outputs.release_notes }}'
                .replace(/%0A/g, '\n')
                .replace(/%0D/g, '\r')
                .replace(/%25/g, '%')
            );

            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tag,
              target_commitish: 'latest-release',
              name: `Maestro v${version}`,
              body: notes,
              draft: true,
              prerelease: false,
            });

            return release.id;

  build:
    needs: [preflight, create-release]
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            target: universal-apple-darwin
            name: macOS
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            name: Windows
          - platform: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            name: Linux

    runs-on: ${{ matrix.platform }}
    name: Build (${{ matrix.name }})

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: src-tauri

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        shell: bash
        run: |
          rm -f package-lock.json
          npm install

      - name: Build MCP server
        shell: bash
        run: |
          if [ "${{ matrix.platform }}" = "macos-latest" ]; then
            cargo build --release -p maestro-mcp-server --target aarch64-apple-darwin
            cargo build --release -p maestro-mcp-server --target x86_64-apple-darwin
            mkdir -p target/release
            lipo -create -output target/release/maestro-mcp-server \
              target/aarch64-apple-darwin/release/maestro-mcp-server \
              target/x86_64-apple-darwin/release/maestro-mcp-server
          else
            cargo build --release -p maestro-mcp-server
          fi

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          args: ${{ matrix.platform == 'macos-latest' && '--target universal-apple-darwin' || '' }}

      - name: List bundle artifacts
        shell: bash
        run: |
          echo "=== Bundle directory contents ==="
          if [ "${{ matrix.platform }}" = "macos-latest" ]; then
            find target/universal-apple-darwin/release/bundle -type f 2>/dev/null || echo "No macOS bundle dir"
          else
            find target/release/bundle -type f 2>/dev/null || echo "No bundle dir"
          fi

      - name: Upload release assets
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          PLATFORM: ${{ matrix.platform }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const releaseId = parseInt(process.env.RELEASE_ID);
            const platform = process.env.PLATFORM;

            const bundleDir = platform === 'macos-latest'
              ? 'target/universal-apple-darwin/release/bundle'
              : 'target/release/bundle';

            // Only upload actual distributable artifacts, not internal packaging files
            const artifactPatterns = [
              /\.dmg$/,
              /\.exe$/,
              /\.msi$/,
              /\.deb$/,
              /\.rpm$/,
              /\.AppImage$/,
              /\.app\.tar\.gz$/,
              /\.app\.tar\.gz\.sig$/,
              /\.nsis\.zip$/,
              /\.nsis\.zip\.sig$/,
              /\.AppImage\.tar\.gz$/,
              /\.AppImage\.tar\.gz\.sig$/,
            ];

            function isArtifact(filename) {
              return artifactPatterns.some(p => p.test(filename));
            }

            // Collect files from known bundle subdirectories
            function findArtifacts(dir) {
              const results = [];
              if (!fs.existsSync(dir)) return results;
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory()) {
                  // Only recurse one level into known subdirs (dmg, macos, nsis, msi, deb, appimage, rpm)
                  const subEntries = fs.readdirSync(fullPath, { withFileTypes: true });
                  for (const sub of subEntries) {
                    if (!sub.isDirectory() && isArtifact(sub.name)) {
                      results.push(path.join(fullPath, sub.name));
                    }
                  }
                } else if (isArtifact(entry.name)) {
                  results.push(fullPath);
                }
              }
              return results;
            }

            const files = findArtifacts(bundleDir);
            core.info(`Found ${files.length} artifacts to upload:`);
            for (const f of files) {
              const stats = fs.statSync(f);
              core.info(`  ${path.basename(f)} (${(stats.size / 1024 / 1024).toFixed(1)} MB)`);
            }

            if (files.length === 0) {
              core.setFailed('No artifacts found in ' + bundleDir);
              return;
            }

            for (const filePath of files) {
              const name = path.basename(filePath);
              const data = fs.readFileSync(filePath);

              core.info(`Uploading ${name} (${(data.length / 1024 / 1024).toFixed(1)} MB)...`);
              try {
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: name,
                  data: data,
                  headers: {
                    'content-type': 'application/octet-stream',
                    'content-length': data.length,
                  },
                });
                core.info(`  Uploaded ${name}`);
              } catch (e) {
                if (e.status === 422) {
                  core.warning(`  ${name} already exists, skipping`);
                } else {
                  throw e;
                }
              }
            }

  generate-updater:
    needs: [preflight, create-release, build]
    runs-on: ubuntu-latest
    name: Generate latest.json

    steps:
      - name: Build latest.json
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ needs.create-release.outputs.release_id }}
          VERSION: ${{ needs.preflight.outputs.version }}
          RELEASE_NOTES: ${{ needs.preflight.outputs.release_notes }}
        with:
          script: |
            const fs = require('fs');
            const releaseId = parseInt(process.env.RELEASE_ID);
            const version = process.env.VERSION;

            // Fetch all release assets
            const { data: assets } = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              per_page: 100,
            });

            core.info('Release assets (' + assets.length + '):');
            for (const a of assets) {
              core.info(`  ${a.name} (${(a.size / 1024 / 1024).toFixed(1)} MB)`);
            }

            // Download a .sig asset and return its text content
            async function getSig(namePattern) {
              const asset = assets.find(a => a.name.endsWith('.sig') && a.name.includes(namePattern));
              if (!asset) {
                core.info('Available .sig assets: ' + assets.filter(a => a.name.endsWith('.sig')).map(a => a.name).join(', '));
                throw new Error(`No .sig asset matching '${namePattern}' found in release`);
              }
              // Download the asset content
              const { data } = await github.rest.repos.getReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                asset_id: asset.id,
                headers: { Accept: 'application/octet-stream' },
              });
              return Buffer.from(data).toString('utf8').trim();
            }

            const macSig = await getSig('.app.tar.gz');
            const winSig = await getSig('.nsis.zip');
            const linuxSig = await getSig('.AppImage.tar.gz');

            // Decode release notes
            const notes = decodeURIComponent(
              (process.env.RELEASE_NOTES || '')
                .replace(/%0A/g, '\n')
                .replace(/%0D/g, '\r')
                .replace(/%25/g, '%')
            );

            const baseUrl = `https://github.com/its-maestro-baby/maestro/releases/download/v${version}`;

            // Find updater bundle asset names
            const macBundle = assets.find(a => a.name.endsWith('.app.tar.gz') && !a.name.endsWith('.sig'));
            const winBundle = assets.find(a => a.name.endsWith('.nsis.zip') && !a.name.endsWith('.sig'));
            const linuxBundle = assets.find(a => a.name.endsWith('.AppImage.tar.gz') && !a.name.endsWith('.sig'));

            if (!macBundle) throw new Error('macOS updater bundle (.app.tar.gz) not found in release assets');
            if (!winBundle) throw new Error('Windows updater bundle (.nsis.zip) not found in release assets');
            if (!linuxBundle) throw new Error('Linux updater bundle (.AppImage.tar.gz) not found in release assets');

            const latest = {
              version: version,
              notes: notes,
              pub_date: new Date().toISOString(),
              platforms: {
                'darwin-universal': {
                  signature: macSig,
                  url: `${baseUrl}/${macBundle.name}`,
                },
                'linux-x86_64': {
                  signature: linuxSig,
                  url: `${baseUrl}/${linuxBundle.name}`,
                },
                'windows-x86_64': {
                  signature: winSig,
                  url: `${baseUrl}/${winBundle.name}`,
                },
              },
            };

            fs.writeFileSync('latest.json', JSON.stringify(latest, null, 2));
            core.info('Generated latest.json:');
            core.info(JSON.stringify(latest, null, 2));

            // Upload latest.json to the release
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: 'latest.json',
              data: fs.readFileSync('latest.json'),
              headers: {
                'content-type': 'application/json',
                'content-length': fs.statSync('latest.json').size,
              },
            });

  publish-release:
    needs: [create-release, generate-updater]
    runs-on: ubuntu-latest
    name: Publish Release

    steps:
      - name: Un-draft release
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: ${{ needs.create-release.outputs.release_id }},
              draft: false,
            });
            core.info('Release published successfully!');
